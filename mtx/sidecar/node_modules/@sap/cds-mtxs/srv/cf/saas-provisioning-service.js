const cds = require('@sap/cds/lib')
const LOG = cds.log('mtx'), DEBUG = cds.debug('mtx')
const { parseHeaders, sendResult } = require('./saas-registry-util')
const migration = require('../../lib/migration/migration')
const DeploymentService = 'cds.xt.DeploymentService'
const JobsService = 'cds.xt.JobsService'
const Tenants = 'cds.xt.Tenants'

if (!cds.env.requires.multitenancy) cds.env.requires.multitenancy = true // we need to run in multitenancy mode for t0 ops
const { t0 = 't0' } = cds.env.requires.multitenancy
const isExtensible = !!cds.requires.extensibility || !!cds.requires['cds.xt.ExtensibilityService']

module.exports = class SaasProvisioningService extends cds.ApplicationService {

  async init() {
    this.on('UPDATE', 'tenant', this.create)
    this.on('READ', 'tenant', this.read)
    this.on('DELETE', 'tenant', this.delete)
    await super.init()
  }

  _options4(data) {
    if (!data?.options && !data._ && !data._application_) return undefined
    const _ = data._application_?.sap ? { hdi: { create: data._application_.sap['service-manager'] } } : data._
    return { ...data.options, _ }
  }

  async _tenantsByDb(tenants) {
    let tenantToDbUrl
    if (cds.requires.db.kind === 'hana') {
      const hana = require('../plugins/hana/srv-mgr')
      tenantToDbUrl = (await hana.getAll(tenants.length > 0 ? tenants : '*')).reduce((res, t) => {
        const id = t.tenant_id ?? t.labels.tenant_id[0]
        if (!t.credentials) throw new Error('Credentials for tenant ' + id + ' are not available.')
        return { ...res, [id]: `${t.credentials.host}:${t.credentials.port}` }
      }, {})
    } else {
      tenantToDbUrl = tenants.reduce((res, t) => ({ ...res, [t]: cds.db.url4(t) }), {})
    }
    const dbToTenants = {}
    for (const tenant of Object.keys(tenantToDbUrl)) {
      const dbUrl = tenantToDbUrl[tenant]
      if (!dbToTenants[dbUrl]) dbToTenants[dbUrl] = new Set
      dbToTenants[dbUrl].add(tenant)
    }
    return dbToTenants
  }

  getAppUrl(subscriptionPayload, subscriptionHeaders) {
    return subscriptionHeaders?.application_url
        ?? process.env.SUBSCRIPTION_URL?.replace(`\${tenant_subdomain}`, subscriptionPayload.subscribedSubdomain)
        ?? 'Tenant successfully subscribed - no application URL provided'
  }

  _getSubscribedTenant(context) {
    const { data, params } = context ?? {}
    const { subscribedTenantId } = data ?? {}
    return subscribedTenantId ?? params?.[0]?.subscribedTenantId
  }

  async create(context) {
    const { headers, data, http } = context
    DEBUG?.('received subscription request with', { data })
    const options = this._options4(data)
    // REVISIT: removing as they are polluting logs -> clearer data/options separation
    delete data._; delete data._application_; delete data.options
    const tenant = this._getSubscribedTenant(context)
    const { isSync } = parseHeaders(http?.req.headers)

    const sps = await cds.connect.to('cds.xt.SaasProvisioningService')
    const appUrl = await sps.getAppUrl(data, headers)
    if (isSync) {
      LOG.info(`subscribing tenant ${tenant}`)
      try {
        const ds = await cds.connect.to(DeploymentService)
        const tx = ds.tx(context)
        await tx.subscribe(tenant, data, options)
        await this._sendCallback('SUCCEEDED', 'Tenant creation succeeded', appUrl)
        cds.context.http.res.set('content-type', 'text/plain')
      } catch (error) {
        await this._sendCallback('FAILED', 'Tenant creation failed')
        throw error
      }
      return appUrl
    } else {
      const { lazyT0 } = cds.requires['cds.xt.DeploymentService'] ?? cds.requires.multitenancy ?? {}
      if (lazyT0) {
        await require('../plugins/common').resubscribeT0IfNeeded(options?._)
      }
      const js = await cds.connect.to(JobsService)
      const tx = js.tx(context)
      return tx.enqueue('subscribe', [new Set([tenant])], { data, options }, error => {
        if (error) this._sendCallback('FAILED', 'Tenant creation failed')
        else this._sendCallback('SUCCEEDED', 'Tenant creation succeeded', appUrl)
      })
    }
  }

  async read(context) {
    const tenant = this._getSubscribedTenant(context)
    if (tenant) {
      const one = await cds.tx({ tenant: t0 }, tx =>
        tx.run(SELECT.one.from(Tenants).columns(['metadata', 'createdAt', 'modifiedAt']).where({ ID: tenant }))
    )
      if (!one) cds.error(`Tenant ${tenant} not found`, { status: 404 })
      const { metadata, createdAt, modifiedAt } = one
      return { subscribedTenantId: tenant, ...JSON.parse(metadata ?? '{}'), createdAt, modifiedAt }
    }
    return (await cds.tx({ tenant: t0 }, tx =>
      tx.run(SELECT.from(Tenants).columns(['ID', 'metadata', 'createdAt', 'modifiedAt']))
    )).map(({ ID, metadata, createdAt, modifiedAt }) => ({ subscribedTenantId: ID, ...JSON.parse(metadata), createdAt, modifiedAt }))
  }

  async _getTenants() {
    const tenants = (await cds.tx({ tenant: t0 }, tx =>
      tx.run(SELECT.from(Tenants, tenant => { tenant.ID }))
    )).map(({ ID }) => ID)
    const mtxTenants = await migration.getMissingMtxTenants(tenants)
    return [...tenants, ...mtxTenants]
  }

  async upgrade(tenantIds, options) {
    if (!tenantIds?.length) return
    const all = tenantIds.includes('*')
    const sharedGenDir = !isExtensible
    if (sharedGenDir) (options ??= {}).skipResources ??= sharedGenDir
    const tenants = all ? await this._getTenants() : tenantIds
    if (sharedGenDir && cds.requires.db.kind === 'hana') { // REVISIT: Ideally part of HANA plugin
      const { resources4, csvs4 } = require('../plugins/hana')
      await resources4('base')
      await csvs4('base')
    }
    const { isSync } = parseHeaders(cds.context.http?.req.headers)
    const {
      clusterSize = 1, workerSize = 1, poolSize = 1
    } = cds.env.requires.multitenancy.jobs ?? cds.env.requires['cds.xt.SaasProvisioningService']?.jobs ?? {}
    const dbToTenants = clusterSize > 1 ? await this._tenantsByDb(tenants) : [new Set(tenants)]
    LOG.info('upgrading', { tenants })
    if (isSync) {
      try {
        const ds = await cds.connect.to(DeploymentService)
        await this.limiter(clusterSize, Object.values(dbToTenants), tenants =>
          this.limiter(workerSize ?? poolSize, Array.from(tenants), t => ds.tx({tenant:t}, tx => tx.upgrade(t, options)))
        )
        await this._sendCallback('SUCCEEDED', 'Tenant upgrade succeeded')
      } catch (error) {
        await this._sendCallback('FAILED', 'Tenant upgrade failed')
        throw error
      }
    } else {
      const js = await cds.connect.to(JobsService)
      const tx = js.tx(cds.context)
      // REVISIT: use jobs service for sync and async operations (might also be interesting for concurrency control)
      return tx.enqueue('upgrade', dbToTenants, { options }, error => {
        if (error) this._sendCallback('FAILED', 'Tenant upgrade failed')
        else this._sendCallback('SUCCEEDED', 'Tenant upgrade succeeded')
      })
    }
  }

  async delete(context) {
    DEBUG?.('received unsubscription request', context.data)
    const { isSync } = parseHeaders(context.http?.req.headers)

    const tenant = this._getSubscribedTenant(context)
    LOG.info(`unsubscribing tenant ${tenant}`)

    if (tenant === t0) {
      const ds = await cds.connect.to(DeploymentService)
      const tx = ds.tx(context)
      return tx.unsubscribe(tenant)
    }

    const one = await cds.tx({ tenant: t0 }, tx =>
      tx.run(SELECT.one.from(Tenants, { ID: tenant }, t => { t.metadata }))
    ) ?? {}
    const metadata = JSON.parse(one?.metadata ?? '{}')

    if (isSync) {
      const ds = await cds.connect.to(DeploymentService)
      const tx = ds.tx(context)
      try {
        await tx.unsubscribe(tenant, { metadata })
        await this._sendCallback('SUCCEEDED', 'Tenant deletion succeeded')
      } catch (error) {
        if (error.statusCode === 404) {
          LOG.info(`tenant ${tenant} is currently not subscribed`)
        } else {
          await this._sendCallback('FAILED', 'Tenant deletion failed')
          throw error
        }
      }
    } else {
      const lcs = await cds.connect.to(JobsService)
      const tx = lcs.tx(context)
      return tx.enqueue('unsubscribe', [new Set([tenant])], { metadata }, error => {
        if (error) this._sendCallback('FAILED', 'Tenant deletion failed')
        else this._sendCallback('SUCCEEDED', 'Tenant deletion succeeded')
      })
    }
  }

  upgradeAll(tenants) {
    LOG.warn(`upgradeAll is deprecated. Use /-/cds/saas-provisioning/upgrade instead.`)
    return this.upgrade(tenants ?? ['*'])
  }

  dependencies() {
    return cds.env.requires['cds.xt.SaasProvisioningService']?.dependencies?.map(d => ({ xsappname: d })) ?? []
  }

  async limiter(limit, payloads, fn) {
    const pending = [], all = []
    for (const payload of payloads) {
      const execute = Promise.resolve().then(() => fn(payload))
      all.push(execute)
      const executeAndRemove = execute.then(() => pending.splice(pending.indexOf(executeAndRemove), 1))
      pending.push(executeAndRemove)
      if (pending.length >= limit) {
        await Promise.race(pending) // eslint-disable-line no-await-in-loop
      }
    }
    return Promise.allSettled(all)
  }

  async _sendCallback(status, message, subscriptionUrl) {
    const originalRequest = cds.context?.http?.req
    const { isSync, isCustomCallback, saasCallbackUrlPath, callbackUrl } = parseHeaders(originalRequest?.headers)
    if (!isSync && callbackUrl) {
      const tenant = this._getSubscribedTenant(originalRequest.body)
      const payload = { status, message, subscriptionUrl }

      // additional payload for internal callback (java)
      if (isCustomCallback) {
          Object.assign(payload, {
              saasRequestPayload: originalRequest.body,
              saasCallbackUrl: saasCallbackUrlPath
          })
      }
      DEBUG?.(`send callback to ${callbackUrl}`)
      try {
          await sendResult(callbackUrl, tenant, payload, isCustomCallback ? originalRequest.headers.authorization : undefined)
      } catch (error) {
          LOG.error(error)
      }
    }
  }
}
