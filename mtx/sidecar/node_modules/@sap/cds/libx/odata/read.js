const metaInfo = require('../_runtime/cds-services/adapter/odata-v4/utils/metaInfo')
const cds = require('../../')
const { toODataResult } = require('./result')
const querystring = require('node:querystring')
const { getPageSize } = require('../_runtime/common/generic/paging')

const _getCount = result =>
  Array.isArray(result)
    ? result.reduce((acc, val) => {
        return acc + ((val && (val.$count || val._counted_)) || (val[0] && (val[0].$count || val[0]._counted_))) || 0
      }, 0)
    : result.$count || result._counted_ || 0

const _calculateNextLink = (req, result) => {
  const $skiptoken = _calculateSkiptoken(req, result)
  if ($skiptoken) {
    const queryParamsWithSkipToken = { ...req.http.req.query, $skiptoken }
    // REVISIT: slice replaces leading '/'. Always starts with '/'?
    result.$nextLink = (
      req.http.req.path.slice(1) + '?' + querystring.stringify(queryParamsWithSkipToken, '&', '=', { encodeURIComponent: e => e })
    )
  }

}

const _calculateSkiptoken = (req, result) => {
  const limit = Array.isArray(req.query)
    ? getPageSize(req.query[0]._target).max
    : req.query.SELECT.limit?.rows?.val
  const top = parseInt(req.http.req.query.$top)
  if (limit === result.length && limit !== top) {
    const token = req.http.req.query.$skiptoken
    if (cds.env.query.limit.reliablePaging && _reliablePagingPossible(req)) {
      const decoded = token && JSON.parse(Buffer.from(token, 'base64').toString())
      const skipToken = {
        r: (decoded?.r || 0) + limit,
        c: req.query.SELECT.orderBy.map(o => ({
          a: o.sort ? o.sort === 'asc' : true,
          k: o.ref[0],
          v: result[result.length - 1][o.ref[0]]
        }))
      }

      if (limit + (decoded?.r || 0) !== top) {
        return Buffer.from(JSON.stringify(skipToken)).toString('base64')
      }
    } else {
      return (token ? parseInt(token) : 0) + limit
    }
  }
}

const _reliablePagingPossible = req => {
  if (req.target._isDraftEnabled) return false
  if (cds.context?.http.req.query.$apply) return false
  if (req.query.SELECT.limit.offset?.val ?? req.query.SELECT.limit.offset > 0) return false
  if (req.query.SELECT.orderBy?.some(o => !o.ref)) return false
  return (
    !req.query.SELECT.columns ||
    req.query.SELECT.columns.some(c => c === '*' || c.ref?.[0] === '*') ||
    req.query.SELECT.orderBy?.every(o => req.query.SELECT.columns?.some(c => o.ref[0] === c.ref?.[0]))
  )
}

module.exports = srv =>
  function read(req, res, next) {
    const query = cds.odata.parse(req.url, { service: srv, baseUrl: req.baseUrl })

    // we need the cds request, so we can access the modified query, which is cloned due to lean-draft, so we need to use dispatch here and pass a cds req
    const cdsReq = new cds.Request({query})
    return srv
      .dispatch(cdsReq)
      .then(result => {
        if (!result.$nextLink) {
          _calculateNextLink(cdsReq, result)
        }

        const lastPathElement = req.path.split('/').slice(-1)[0]
        if (lastPathElement === '$count') {
          result = _getCount(result)
          return res.send(result.toString())
        } else if (lastPathElement === '$value' && query._propertyAccess) {
          return res.send(result[query._propertyAccess].toString())
        }

        // mainly for @odata.context
        const info = metaInfo(query, 'READ', srv, {}, req, false)
        result = toODataResult(result, info)

        // Express interprets numbers as HTTP status codes
        return res.send(typeof result === 'number' ? result.toString() : result)
      })
      .catch(next)
  }
